## Практическое задание 1: ICMP симуляция

### Файл для скачивания

[Практическое задание 1: ICMP симуляция](https://github.com/Vinnjy/cisco/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%201.pkt)

### Описание

* Построить сеть из 3 ноутбуков, 1 пк, 1 сервера и 2 хабов.
* Задать для 3 ноутбуков IP-адреса в диапазоне: 192.168.1.1-192.168.1.3, для пк: 192.168.1.4, для сервера: 192.168.1.5.
* Посмотреть, что происходит при передаче в режиме симуляции.

### Оглавление
[Модель OSI, TCP/IP](#title0)

[ICMP симуляция](#title1)

<br>

<br>

<br>

## <a id="title0">Модель OSI, TCP/IP</a>

<details>
  <summary>OSI</summary>
  <br>

  Эталанноая модель, которая подробно демонстрирует, что происходит с данными при передаче. На практике не используется.
</details>

<details>
  <summary>TCP/IP</summary>
  <br>

  Модель, которая используется на практике. 
  
  Объединяет в себе функционал некоторых уровней модели OSI в один:
  
  * Прикладной объединяет все уровни модели OSI, которые работают с данными. 
  
  * Канальный объединяет физический и канальный уровень модели OSI.

  <img width="1024" height="767" alt="image" src="https://github.com/user-attachments/assets/4704e277-93ea-4dbf-a559-3dbee3398325" />
</details>

<details>
  <summary>Инкапсуляция/Декапсуляция</summary>

   1. Перед передачей данные проходят каждый уровень, начиная с прикладного, заканчивая физическим.
   
         * По физическому каналу доходят до другого устройтсва.
         
         * Там проходят все уровни от физического до прикладного (если рассматривать модель OSI и конечные устройства).

   Эти процессы называются **инкапсуляцией** и **декапсуляцией**.

   Инкапсуляция:

   <img width="848" height="517" alt="image" src="https://github.com/user-attachments/assets/7af9abe1-89ac-408b-8e63-e5790e9f2d3a" />
   
   <br>

   Декапсуляция:
   
   <img width="837" height="495" alt="image" src="https://github.com/user-attachments/assets/dea542ff-39ac-413a-94b5-68271300ee2b" />

   <br>
   
   > Стоит отметить, что каждый уровень ничего не знает о работе другого уровня, всего лишь передаёт данные другому.

   <br>
  
   2. На каждом уровне при инкапсуляции к данным добавляются служебная информация (заголовки).
         
         * При декапсуляции их считывают и преобразуют до исходного состояния.

   3. Физический, канальный, сетевой - **уровни среды**; остальные - **уровни хоста**. Физический уровень и канальный уровень (MAC) реализованы на уровне железа, канальный уровень (LLC) и остальные на уровне программ.

   4. Уровни прикладной, представления, сеансовый работают с данными.

   5. Транспортный с сегментами/датаграммами.
   
   6. Сетевой с пакетами.
   
   7. Канальный с кадрами.
   
   8. Физический с сигналами (биты). 
</details>

<details>
  <summary>Пример</summary>
  <br>

   1. **Прикладной уровень** позволяет приложению взаимодействовать с сетью.
   
   Протоколы:
   <ul>
      <li>HTTP</li>
      <li>DNS</li>
      <li>DHCP</li>
      <li>RTP</li>
      <li>...</li>
   </ul>

   > 1. Допустим, открыли браузер, ввели адрес и нажали enter.
   > 2. Браузер (клиент) должен отправить запрос на сервер, чтобы получить данные. На прикладном уровне данныe - адрес сайта.

   <br>
   <br>
   <br>
   
   2. **Уровень представления** обеспечивает преобразование данных в формат, пригодный для передачи и понятный получателю.

   Кодировки:
   <ul>
      <li>ASCII</li>
      <li>Unicode</li>
   </ul>
   
   Протоколы для шифрования:
   <ul>
      <li>SSL/TLS</li>
   </ul>
   
   Cжатие:
   <ul>
      <li>MPEG</li>
      <li>MP3</li>
      <li>JPEG</li>
      <li>...</li>
   </ul>

   > 3. Данные спускаются на уровень представления. Запрос формматируется для передачи по сети, а данные кодируются.

   <br>
   <br>
   <br>
   
   3. **Cеансовый уровень** - управляет сеансами связи. Показывает: какой тип соединения будет применён.

   Типы:
   <ul>
      <li><b>симплексное</b> - в одном напралении передача</li>
      <li><b>полудуплексное</b> - в обоих направлениях, но неодновременно</li>
      <li><b>дуплексное</b> - одновременно в обоих направлениях</li>
   </ul>
   
   Прококолы:
   <ul>
      <li>SIP</li>
      <li>...</li>
   </ul>

   > 4. Данные (уже не текст, который вводили) поступают на сеансовый уровень. В данном примере нет необходимости задействовать протоколы этого уровня.

   <br>
   <br>
   <br>
   
   4. **Транспортный уровень** обеспечивает передачу данных между отправителем и получателем.

   > 5. Данные переданы на траснпортный уровень.
   > При передаче данные разбиваются на ***сегменты/датаграммы***, к каждому сегменту добавляются ***заголовки*** со служебной информацией. Указываются **логические порты получателя и отправителя**.

   * **Мультиплексирование** — это механизм, который позволяет передавать данные множества различных сессий (или потоков данных) между одними и теми же хостами, используя один и тот же транспортный протокол с помощью лог.портов.

   Прококолы:
   <ul>
      <li>TCP</li>
      <li>UDP</li>
      <li>...</li>
   </ul>

   **TCP** обеспечивает надёжную передачу с помощью установки соединения.

   <img width="913" height="398" alt="image" src="https://github.com/user-attachments/assets/6439cdf2-7298-4227-9320-208abef69f17" />

   * **Управление соединениями** — это установление и поддержка логической связи между двумя устройствами.
   
   * **Управление потоками** — это контроль за скоростью передачи данных внутри этого соединения, чтобы предотвратить переполнение буфера получателя.

   * **MSS** - максимальный размер полезных данных, который может быть отправлен в одном сегменте (пакете), и не включает заголовки TCP и IP. (важен на транспортном уровне)

   * **MTU** (maximum transmission unit) - максимальный размер полезного блока данных, который может быть передан протоколом без фрагментации. Размер части должен быть таков, чтобы не был превышен MTU на сетевом уровне. (важен на канальном и сетевом уровне модели OSI)

   > То есть MTU - максимальный размер всего пакета, который включает в себя как заголовки IP и TCP, так и саму полезную нагрузку (данные).
   > MSS - меньше MTU, определяет максимальный размер только полезной нагрузки (данных) в сегменте TCP, не включая заголовки IP и TCP. 

   Использует ***правило тройного рукопожатия***:
   <ol>
      <li>устройство А отправляет сегмент с флагом SYN (что хочет начать передачу)</li>
      <li>устройство В отпраляет сегмент SYN+ACK (готов принимать передачу)</li>
      <li> устройство А отправляет сегмен с флагом ACK (мы оба согласны, начинаю передачу).</li>
   </ol>

   > Стоит отметить, что если зайдёте в cisco packet tracer и используете симуляцию для демонстрации работы HTTP протокола. Вы заметите, что после HTTP-ответа используется TCP протокол для завершения передачи (флаг FIN), работает по правилу тройного рукопожатия.

   <img width="388" height="305" alt="image" src="https://github.com/user-attachments/assets/d4f9660e-7434-46d1-b2e2-dee2f782feea" />

   <img width="1103" height="573" alt="image" src="https://github.com/user-attachments/assets/f0c176fd-c1cb-4b8e-b8ce-010191c62197" />

   <br>
   <br>
  
   Размер TCP сегмента от 20 байт (60 байт с опциями) до 65535 байт. На практике 1500 байт из-за MTU.

   * **Контрольная сумма** определить наличие ошибок в сегменте.

   * **Порядковый номер** - номер сегнмента.

   * **Номер подтверждения** - следующий номер сегмента.

   * **Размер окна** - для управления потоком сегментов.

   * **Смещение** - длина заголовка TCP-сегмента.

   * **Зарезервировано** - для будущего использования. (1 битовое слово - 5 байт)

   * **Указатель срочности** - для критично важных протоколов (SMTP, FTP).

   * **Опции** - используется источником или приёмником для определения MSS. Для получения информации о параметрах функционирования сети. Для дополнительных возможностей по управлению соединениями.

   * **Флаги**(0 или 1 = 1 бит):
   
       * **ACK** - сегмент подтверждения.
    
       * **SYN** - установка соединения между 2 устройствами.
    
       * **FIN** - устанавливается стороной, завершающей передачу данных, чтобы сообщить, что дальше ... Для логического завершения TCP-соединения 
    
       * **RST** - принуждающий разрыв (сбой соединения, предотвращщение нападения).
    
       * **UGR** - для срочности.
    
       * **PSH** - для немедленной отправки данных (минуя буферизацию).
   
   <br>
   <br>
   
   **UDP** использует датаграммы.

   Обеспечивает быструю передачу, но нет надёжности, порядок сегментов, целостность данных при передаче.

   <img width="650" height="211" alt="image" src="https://github.com/user-attachments/assets/9f1b028a-5ccd-48b1-bd87-1667d2a842f4" />

   <img width="378" height="114" alt="image" src="https://github.com/user-attachments/assets/005f55f2-7f3e-4b82-98fe-546635600256" />

   <img width="670" height="227" alt="image" src="https://github.com/user-attachments/assets/febec19a-ddb8-4c44-a672-4d821f8c070c" />

   <br>
   
   * **Контрольная сумма** - для проверки целостности данных при их передаче.

   * **Длина заголовка** - заголовок + полезные данные.
  
   * TCP учитывает MTU (Maximum Transmission Unit), а UDP — нет.

   > В практической работе с DHCP, DNS, WEB серверами можете запустить симуляции и посмотреть структуру сегментов/датаграмм.
   
   > Для TCP используйте браузер в качестве HTTP запроса.

   > Для UDP используйте DNS: команда nslookup с полным доменным именем сайта (об этом в следующей практической работе).

   <br>
   <br>
   <br>

   <br>
   
   5. **Сетевой уровень** обеспечивает маршрутизацию данных по сети.

   Протоколы:
   <ul>
      <li>IP</li>
      <li>ICMP</li>
      <li>ARP</li>
      <li>...</li>
   </ul>

   > 6. Сегменты переданы на сетевой уровень.
   > Сегменты разделяются на ***пакеты***. ***Сегмент = заголовок + данные***. ***Пакет = сегмент + заголовок***. Заголовок сетевого уровня состоит из многих служебных параметров, но главное, что надо знать, что содержит **IP-адрес отправителя и получателя**.

   <img width="434" height="198" alt="image" src="https://github.com/user-attachments/assets/33da9fef-0c1e-4292-962e-56571bc52a20" />
   
   <img width="894" height="450" alt="image" src="https://github.com/user-attachments/assets/14c97a75-4853-4ea6-a8b6-1a4fab176e17" />

   1. Заголовок (Header). Содержит управляющую  информацию:

        * **Версия** (Version): Указывает, какая версия IP используется (например, IPv4 или IPv6).

        * **Длина заголовка** (Internet Header Length): Определяет длину заголовка в 32-битных словах (отрезках по 4 байта).

        * **Тип обслуживания** (Type of Service/DiffServ): Позволяет управлять приоритетом доставки пакетов. Маркировка трафика.

        * **Общая длина** (Total Length): Общая длина пакета = заголовок + данные.

        * **Идентификатор** (Identification): Используется для сборки фрагментированных пакетов.

        * **Флаги** (Flags): Определяют, может ли пакет быть фрагментирован и есть ли ещё фрагменты.

        * **Смещение фрагмента** (Fragment Offset): Позиция фрагмента в исходном пакете.

        * **Время жизни** (Time To Live - TTL): Количество маршрутизаторов, через которые пакет может пройти, прежде чем быть отброшенным.

        * **Протокол** (Protocol): Указывает, какой протокол верхнего уровня (например, TCP, UDP) находится в полезной нагрузке.

        * **Заголовочная сумма** (Header Checksum): Проверочная сумма для заголовка, используемая для обнаружения ошибок.

        * **IP-адрес отправителя** (Source IP Address): IP-адрес устройства, отправившего пакет.

        * **IP-адрес получателя** (Destination IP Address): IP-адрес устройства, для которого пакет предназначен.

        * **Опции** (Options): Дополнительные поля для отладки, тестирования или специфических настроек маршрутизации.

   2. **Полезная нагрузка** (Payload/Data): непосредственно данные, которые передаются, например, сегмент TCP или датаграмма UDP.
   
   <br>
   <br>
   <br>
   <br>
   
   <br>
   
   6. **Канальный уровень** управляет доступом среде передачи данных, включая адресацию (MAC).

   Обеспечивает, чтобы данные дошли по правильному MAC-адресу, помогает передавать данные по общей среде. Также занимается проверкой и исправлением данных (LLC).

   > 7. Пакеты передаются на канальный уровень. Там они разбиваются на ***кадры***, к ним добавляются заголовки. ***Кадр = пакет + заголовок***. Заголовок содержит **MAC-адреса отправителя и получателя**, также **трейлер** для проверки целостности данных.

   <img width="446" height="135" alt="image" src="https://github.com/user-attachments/assets/6df47028-157d-49ac-9361-4614dcdf65ac" />

   <img width="1022" height="87" alt="image" src="https://github.com/user-attachments/assets/ad3c902e-b022-487f-8862-a26782bad46c" />

   <br>
   <br>
    
   ***Роль преамбулы***:
    
   1. **Сигнал о начале**: преамбула предупреждает приемник о том, что скоро начнется передача данных, и он должен быть готов к их приему. 

   2. **Синхронизация**: чередующиеся единицы и нули позволяют приемнику синхронизировать свои тактовые генераторы с передатчиком, чтобы точно считывать биты данных. 

   ***Структура кадра Ethernet***:

   * **Преамбула** (7 байт).

   * **SFD** (Start Frame Delimiter): Ограничитель начала кадра (1 байт), который окончательно указывает на начало полезной части кадра.

   * MAC-адрес назначения: (6 байт) = **DEST**.

   * MAC-адрес источника: (6 байт) = **SRC**.

   * **Тип/Длина**: (2 байта): Указывает на протокол более высокого уровня или на длину поля данных.

   * **Полезная нагрузка**: (данные).

   * **FCS** (Frame Check Sequence): Контрольная сумма для проверки правильности передачи данных.

   <br>
   <br>
   <br>
   
   7. **Физический уровень** отвечает за физическую передачу данных через среду (кабели, радиоволны, ...).

   <br>
   <br>
   <br>
   
   > 8. Данные поступают на физический уровень, где передаются в виде 0 и 1.

   > 9. Когда сигналы (биты) доходят до получателя, сетевая карта преобразует их в кадры и отправляет на уровень выше.

   > 10. На канальном уровне проверяется MAC-адрес получателя (совпадает ли полученное значение с MAC-адресом сетевой карты).
   > Если нет, то кадр отбрасывается. Если да, то высчитвается полученная сумма данных и сравнивается со значением в трейлере. Если нет, то кадр отбрасывается. Если да, то преобрзование в пакет и отправка на уровень выше.
   
   > 11. На сетевом уровне идёт проверка IP-адреса получателя. Если совпало, то преобразование в сегмент и отправка на уровень выше.
   
   > 12. На транспортном уровне проверка служебной иформации из заголовков (что сегмент передался, какой протокол использовался (если TCP, то отправят SYN+ACK или FIN+ACK), для какого порта).
   
   > 13. На остальных уровнях запрос обработается и вышлет HTTP-ответ.
   
   > Далее тоже самое только уже для ответа. Если объём данных будет очень большим, то их поделят, спустят на транспортный уровень.
   
   > Cтоит отметить, что хабы понимают только физический уровень, коммутаторы - физический и канальный, маршрутизаторы - физический и канальный и сетевой.
   > Когда через них проходят данные, они декапсулируются и инкапсулируются для прохождения дальше по сети, как это было с конечными устройствами.

</details>

<br>

<br>

<br>

## <a id="title1">ICMP симуляция</a>

1. Построить сеть

<details>
  <summary>Схема</summary>
  <br>

  <img width="683" height="376" alt="image" src="https://github.com/user-attachments/assets/cf60245b-9f3a-48f8-b4ed-8f13c2459bae" />
</details>

> Чтобы прописать IP-адреса и префиксы, нажмите на ***Place Note*** (справа есть панель, выберите второй, считая сверху)

2. Пропишем IP-configuration и названия конечных устройств.

<details>
  <summary>comp1</summary>
  <br>

  <img width="299" height="242" alt="image" src="https://github.com/user-attachments/assets/b39ad07e-428b-46c8-8f18-bb1a86de4710" />
</details>

<details>
  <summary>comp2</summary>
  <br>

  <img width="305" height="244" alt="image" src="https://github.com/user-attachments/assets/2502c4d9-0d4f-420e-8103-fa9014e2ed1e" />
</details>

<details>
  <summary>comp3</summary>
  <br>

  <img width="307" height="243" alt="image" src="https://github.com/user-attachments/assets/80cf1f5a-9a3a-427c-b758-a9eabd3784d9" />
</details>

<details>
  <summary>comp4</summary>
  <br>

  <img width="305" height="253" alt="image" src="https://github.com/user-attachments/assets/a643d405-e6ee-4823-a267-67541865561e" />
</details>

<details>
  <summary>server1</summary>
  <br>

  <img width="275" height="289" alt="image" src="https://github.com/user-attachments/assets/c038fde5-000a-41e3-9646-fd7a39d1226c" />
</details>

<details>
  <summary>ICMP</summary>
  <br>

  Протокол для проверки сети и доступности устройств. Состоит из:
  <ul>
    <li>ICMP Echo Request (эхо запрос)</li>
    <li>ICMP Echo Reply (эхо ответ)</li>
  </ul>

  ICMP инкапсулируется в IP-пакеты, так как пакеты передаются по сети.

  > Также для диагностики используют команду **traceroute** - показывает сколько маршрутизаторов прошёл пакет и сколько времени занимает обработка пакета на каждом узле.

  > **Wireshark** - графическая утилита для захвата и анализа трафика (отдельное приложение). 
</details>

<details>
  <summary>Структура ICMP</summary>
  <br>

  <ol>
    <li>Заголовок:</li>
    <ul>
      <li><b>Тип сообщения</b> - 0 для ответа, 8 для запроса</li>
      <li><b>Код</b> - информация о типе сообщения (у типа 0 и 8 только код 0, который означает эхо-запрос и эхо-ответ)</li>
      <li><b>Контрольная сумма</b> - контрольная сумма для проверки целостности сообщения</li>
      <li><b>Идентификатор</b>. Если делается пинг, то посылается, как правило 4 эхо-запроса, id каждого не меняется</li>
      <li><b>Порядковый номер</b>. Если делается пинг, то посылается, как правило 4 эхо-запроса, порядковый номер каждого меняется</li>
    </ul>
    <li>Поле данных</li>
    <ul>
      <li>Данные отправителя. Оно может быть пустым или включать случайные данные, что помогает проверить, вернулись ли эти же данные обратно</li>
    </ul>
  </ol>

  Пример:

  <img width="365" height="90" alt="image" src="https://github.com/user-attachments/assets/e83d3e84-00f5-41cc-9ff5-474406c407bd" />
</details>

3. Пропингуем comp1 и сервер в симуляции и посмотрим, что происходит.

<details>
  <summary>Порядок действий в приложении</summary>
  <br>

  1. Где написано Realtime, за ним находится режим Simulation (нажмите на него).
  
  2. Нажмите на Edit Filters, уберите во всех вкладках галочки, кроме ICMP, ARP.
  
  3. Нажимаем на comp1 -> Desktop -> Command Prompt -> прописываем команду ping 192.168.1.5 -> Enter -> Esc.
</details>

4. Результат:

<details>
  <summary>Симуляция ARP</summary>
  <br>

  > Формируется ICMP эхо-запрос, но перед ним отправят ARP-запрос, чтобы узнать MAC-адрес получателя.
  
  > На следующих скриншотах показан путь ARP.

  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/f989caa6-9c1f-4303-b0e6-022f9c4757cb" />

  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/5d7922bd-8a9e-464c-9e78-9a743f90c666" />

  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/1ee4b2ee-7a7f-4fa4-a1c1-607893072a90" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/c9a1a2a7-c3ec-46c8-adbe-36593e270109" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/dbc52482-dc55-4340-8cb5-4f4630665d57" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/7b3240cf-5f8e-46f8-8128-60c975da8114" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/1b85bfa8-6757-4de2-a7eb-b106d73a044e" />
</details>

<details>
  <summary>Симуляция ICMP</summary>
  <br>

  > На следующих скриншотах показан путь ICMP эхо-запроса и ответа.

  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/0e19432c-1fc1-4d22-8fb9-4102566201cd" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/bd1e4ecd-b41b-468c-965f-3f71ce8aff87" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/21792b5f-9c94-458a-9cba-b09532617aab" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/62534d26-0172-4d6b-b08f-7358356714e2" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/2c701bdb-8595-4dfe-ad01-72b7543fd628" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/7beec011-26b0-4b72-9961-43e87324c645" />
  
  <img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/c9682058-e077-4a40-ba9f-5d567d89170d" />
  
  > Таких пакетов ещё 3 (демонстрация только одного).
</details>

<details>
  <summary>Command Prompt</summary>
  <br>

 <img width="639" height="772" alt="image" src="https://github.com/user-attachments/assets/355f1d7e-1e3e-4b4e-98a8-0a92d1cfd679" />
</details>
